{
  "entityType" : "CONVERTER",
  "entity" : {
    "additionalInfo" : {
      "description" : ""
    },
    "configuration" : {
      "scriptLang" : "JS",
      "decoder" : "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
      "tbelDecoder" : "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions 'decodeToString' and 'decodeToJson' are already built-in **/\n\nreturn result;",
      "encoder" : "// Convert a value to a byte array in little-endian format\nfunction toLittleEndianByteArray(value, byteSize) {\n    var byteArray = [];\n    for (var i = 0; i < byteSize; i++) {\n        byteArray.push(value & 0xFF);\n        value = value >> 8;\n    }\n    return byteArray;\n}\n\n// Get the current timestamp or use the provided one\nvar timestamp = msg.timestamp ? Math.floor(new Date(msg.timestamp).getTime() / 1000) : Math.floor(new Date().getTime() / 1000);\nvar timestampBytes = toLittleEndianByteArray(timestamp, 4); // 4 bytes\n\n// Get the message ID from the `msg` object, or generate a random one\nvar messageId = msg.messageId || Math.floor(Math.random() * 65535);\nvar messageIdBytes = toLittleEndianByteArray(messageId, 2); // 2 bytes\n\n// Task type is always \"valveControl\"\nvar taskTypeByte = 0x01; // 1 byte for \"valveControl\"\n\n// Determine which valve is being controlled and set the corresponding bytes\nvar valveNumberByte;\nvar valveStateByte;\n\nif (msg.hasOwnProperty('Valve1State')) {\n    valveNumberByte = 0x00;  // Valve 1\n    valveStateByte = msg.Valve1State === true ? 0x01 : 0x00;  // \"01\" for open, \"00\" for closed\n} else if (msg.hasOwnProperty('Valve2State')) {\n    valveNumberByte = 0x01;  // Valve 2\n    valveStateByte = msg.Valve2State === true ? 0x01 : 0x00;  // \"01\" for open, \"00\" for closed\n} else {\n    // Handle the case where neither Valve1State nor Valve2State is provided\n    valveNumberByte = 0x00;  // Default to 0 if no valve state is provided\n    valveStateByte = 0x00;   // Default to \"closed\"\n}\n\n// Hardcoded instruction type for valve control\nvar instructionTypeByte = 0x09;  // 1 byte for \"09\"\n\n// Combine all bytes into a single array\nvar finalBytes = [].concat(\n    timestampBytes,  // Timestamp\n    messageIdBytes,  // Message ID\n    [taskTypeByte],  // Task Type\n    [instructionTypeByte, valveNumberByte, valveStateByte]  // Task Data\n);\n\n// Convert the byte array to a Base64 string\nvar base64Payload = btoa(String.fromCharCode.apply(null, finalBytes));\n\n// Construct the downlink message\nvar data = {\n    downlinks: [{\n        f_port: 2,  // Specify the port\n        confirmed: true,\n        frm_payload: base64Payload,  // The Base64 encoded payload\n        priority: \"NORMAL\"\n    }]\n};\n\n// Prepare the result object to return\nvar result = {\n    contentType: \"JSON\",  // Specify the content type of the downlink message\n    data: JSON.stringify(data),  // The downlink data in JSON format\n    metadata: {\n        devId: 'eui-70b3d57ed006996d'  // Example static devId\n    }\n};\n\n// Return the result object\nreturn result;",
      "tbelEncoder" : "// Define the instructionType as always \"09\" for valve control\nvar instructionType = \"09\";\n\n// Define variable to hold the valveState value\nvar valveState;\n\n// Explicitly set the valveState based on Valve1State\nif (msg.Valve1State === true) {\n    valveState = \"01\";  // Valve state open\n} else {\n    valveState = \"00\";  // Valve state closed\n}\n\n// Construct the detailed downlink message\nvar detailedMessage = {\n    metadata: {\n        timestamp: new Date().toISOString(),  // Current timestamp\n        messageId: Math.floor(Math.random() * 100000)  // Random messageId\n    },\n    task: {\n        type: \"valveControl\",  // Task type is valve control\n        data: {\n            instructionType: instructionType,  // Fixed instructionType \"09\"\n            valveNumber: \"01\",  // Hardcoded valve number\n            valveState: valveState  // Use the explicitly set valveState\n        }\n    }\n};\n\n// Convert the detailed message to a JSON string\nvar jsonString = JSON.stringify(detailedMessage);\n\n// Encode the JSON string to Base64\nvar base64Payload = btoa(jsonString);\n\n// Construct the data object with the required structure\nvar data = {\n    downlinks: [{\n        f_port: 2,  // Specify the port\n        confirmed: false,  // Add the confirmed field\n        frm_payload: base64Payload,  // The Base64 encoded payload\n        priority: \"NORMAL\"  // Priority level\n    }]\n};\n\n// Construct the result object\nvar result = {\n    contentType: \"JSON\",  // Specify the content type\n    //data: data,\n    data: JSON.stringify(data),  // Convert the data object to a JSON string\n    metadata: {\n        devId: 'eui-70b3d57ed006996d'  // Example static devId\n    }\n};\n\n// Return the result object\nreturn result;",
      "updateOnlyKeys" : [ "manufacturer" ]
    },
    "debugMode" : true,
    "edgeTemplate" : false,
    "externalId" : null,
    "id" : {
      "entityType" : "CONVERTER",
      "id" : "e2e4ba40-5722-11ef-887e-effae2bd2f60"
    },
    "name" : "Downlink Data Converter TTN",
    "type" : "DOWNLINK"
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}