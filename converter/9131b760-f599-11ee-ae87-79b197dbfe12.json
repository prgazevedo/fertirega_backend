{
  "entityType" : "CONVERTER",
  "entity" : {
    "additionalInfo" : {
      "description" : ""
    },
    "configuration" : {
      "scriptLang" : "JS",
      "decoder" : "// Decode an uplink message from TTN\n    // payload - array of bytes\n    // metadata - key/value object\n\n/** Decoder **/\n\n// Decode payload to JSON\nvar data = decodeToJson(payload);\nvar customerName = 'Regas4.0';\nvar groupName = 'Regas';\nvar manufacturer = 'M5Stack';\nvar deviceName = data.end_device_ids.device_id;\nvar deviceType = data.end_device_ids.application_ids.application_id;\nvar appName = data.end_device_ids.application_ids.application_id;\n\n// Use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var deviceName = 'Irrigation controller';\n// var deviceType = 'controller';\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n    // Use deviceName and deviceType or assetName and assetType, but not both.\n    deviceName: deviceName,\n    deviceType: deviceType,\n    applicationName: appName,\n    // assetName: assetName,\n    // assetType: assetType,\n    customerName: customerName,\n    groupName: groupName,\n    attributes: {\n        model: 'ATOM_LORA',\n        serialNumber: 'No Serial',\n        integrationName: metadata['integrationName'],\n        manufacturer: manufacturer\n    },\n    telemetry: {\n\n        rawData: decodeToString(payload)\n    }\n};\n\n/** Helper functions **/\n\nconst enrichedTelemetry = enrichTelemetryWithDataNames(result.telemetry, decodeSensorData(data.uplink_message.decoded_payload));\n\nresult.telemetry = enrichedTelemetry; // Update telemetry in the result object\n\n/** Helper functions **/\n  // Mapping for sensor data based on the table\nfunction enrichTelemetryWithDataNames(telemetryData, parsedData) {\n  const dataNames = {}; // Use Set for unique data names\n\n  // Extract data names from parsed data\n  parsedData.forEach((sensorData) => {\n    telemetryData[sensorData.dataName]= sensorData.value;\n  });\n\n  // Enrich telemetry with data names\n  return {\n    ...telemetryData, // Spread existing telemetry data\n  };\n}\n  \nfunction decodeSensorData(jsonData) {\n    const sensorDataList = [];\n    const sensorMap = [\n    { sensorName: \"Battery Power\", parentId: 0x0000, dataName: \"Battery Percentage\", subId: 0x00, dataType: \"uint8_t\" },\n    { sensorName: \"Battery Power\", parentId: 0x0000, dataName: \"Charging State\", subId: 0x01, dataType: \"uint8_t\" },\n    { sensorName: \"GXHTC\", parentId: 0x0004, dataName: \"Temperature\", subId: 0x00, dataType: \"float\", decimalPlaces: 2 },\n    { sensorName: \"GXHTC\", parentId: 0x0004, dataName: \"Humidity\", subId: 0x01, dataType: \"float\", decimalPlaces: 2 },\n    { sensorName: \"OUTDOOR_VALVE\", parentId: 0x0006, dataName: \"VALVE_0_STATUS\", subId: 0x00, dataType: \"float\", decimalPlaces: 2 },\n    { sensorName: \"OUTDOOR_VALVE\", parentId: 0x0006, dataName: \"VALVE_1_STATUS\", subId: 0x01, dataType: \"float\", decimalPlaces: 2 },\n    { sensorName: \"OUTDOOR_VALVE\", parentId: 0x0006, dataName: \"PULSE_COUNTER_0\", subId: 0x02, dataType: \"float\", decimalPlaces: 2 },\n    { sensorName: \"OUTDOOR_VALVE\", parentId: 0x0006, dataName: \"PULSE_COUNTER_1\", subId: 0x03, dataType: \"float\", decimalPlaces: 2 },\n    \n  ];\n    // Iterate through each sensor object in the JSON\n    for (const [sensorIdStr, sensorObj] of Object.entries(jsonData)) {\n      const sensorId = sensorObj.sensor_id;\n      sensorObj.sensor.forEach((dataPoint) => {\n        const { data, pk_id } = dataPoint;\n        const sensorMatch = sensorMap.find(\n          (sensor) => sensor.parentId === sensorId && sensor.subId === pk_id\n        );\n  \n        if (sensorMatch) {\n          const parsedData = sensorMatch.dataType === \"uint8_t\"\n            ? Math.round(data) // Round for uint8_t\n            : data; //parseFloat(data.toFixed(sensorMatch.decimalPlaces)); // Round for floats\n  \n          sensorDataList.push({\n            sensorName: sensorMatch.sensorName,\n            parentId: sensorMatch.parentId,\n            dataName: sensorMatch.dataName,\n            subId: sensorMatch.subId,\n            dataType: sensorMatch.dataType,\n            value: parsedData,\n            unit: sensorMatch.unit,\n          });\n        }\n      });\n    }\n  \n    return sensorDataList;\n  }\n  \n\n  \nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\n\nreturn result;",
      "tbelDecoder" : "var data = decodeToJson(payload);\n\nvar deviceName = data.end_device_ids.device_id;\nvar deviceType = data.end_device_ids.application_ids.application_id;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodeFrmPayload(input) {\n    var output = { attributes:{}, telemetry: {}};\n    // --- Decoding code --- //\n\n    output.telemetry.HEX_bytes = bytesToHex(input);\n\n    // If the length of the input byte array is odd - we cannot parse it using the example below\n    if (input.length > 0) {\n        for (var i = 0; i < input.length; ) {\n            var channel_id = input[i++];\n            if (i < input.length) {\n                var channel_type = input[i++];\n                // BATTERY\n                if (channel_id === 0x01 && channel_type === 0x75) {\n                    output.telemetry.battery = input[i];\n                    i += 1;\n                }\n                // PIR\n                else if (channel_id === 0x03 && channel_type === 0x00) {\n                    output.telemetry.pir = input[i] === 0 ? \"normal\" : \"trigger\";\n                    i += 1;\n                }\n                // DAYLIGHT\n                else if (channel_id === 0x04 && channel_type === 0x00) {\n                    output.telemetry.daylight = input[i] === 0 ? \"dark\" : \"light\";\n                    i += 1;\n                }\n            }\n        }\n    }\n\n    // --- Decoding code --- //\n    return output;\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.uplink_message.received_at;\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\nif ((data.simulated != null && data.simulated) || dateString == null) {\n    dateString = data.received_at;\n}\nvar timestamp = new Date(dateString).getTime();\nvar timestamp = -1;\nif (dateString != null) {\n  timestamp = new Date(dateString).getTime();\n  if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n          millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n          if (dateString.length >= secondsSeparatorIndex + 3) {\n              dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n          }\n      } else {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n              dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n  }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.devEui = data.end_device_ids.dev_eui;\nattributes.fPort = data.uplink_message.f_port;\n// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually\nattributes.correlation_ids = data.correlation_ids;\n\n// You can exclude some keys from the result\nvar excludeFromTelemetryList = [\"uplink_token\", \"gateway_id\", \"settings\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"network_ids\"];\nvar excludeFromAttributesList = [\"uplink_token\", \"gateway_id\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"session_key_id\", \"dev_eui\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.\nvar telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);\nvar attributesData = {};\nattributesData.putAll(toFlatMap(data.uplink_message.settings, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.end_device_ids, excludeFromAttributesList, false));\n\n// Passing incoming bytes to decodeFrmPayload function, to get custom decoding\nvar customDecoding = {};\nif (data.uplink_message.get(\"frm_payload\") != null) {\n  customDecoding = decodeFrmPayload(base64ToBytes(data.uplink_message.frm_payload));\n}\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: {\n        ts: timestamp,\n        values: telemetry\n    }\n};\n\nreturn result;",
      "encoder" : null,
      "tbelEncoder" : null,
      "updateOnlyKeys" : [ "devEui", "fPort", "bandwidth", "spreading_factor", "coding_rate", "frequency", "net_id", "tenant_id", "cluster_id", "cluster_address", "join_eui", "dev_addr", "battery", "pir", "daylight", "eui" ]
    },
    "debugMode" : true,
    "edgeTemplate" : false,
    "externalId" : null,
    "id" : {
      "entityType" : "CONVERTER",
      "id" : "9131b760-f599-11ee-ae87-79b197dbfe12"
    },
    "name" : "Uplink data converter TTN",
    "type" : "UPLINK"
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}